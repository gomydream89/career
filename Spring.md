## 객체지향의 개념과 Spring 특징
(참고) : https://velog.io/@mystyle730/Chapter16-ResponseEntity-RESTful%EC%82%AC%EC%9A%A9-%EC%9D%B4%EC%9C%A0-%EA%B7%9C%EC%95%BD-%EA%B5%AC%EC%A1%B0
객체지향이란 실세계를 모델링하여 소프트웨어를 개발하는 방법론입니다. (OOP : OBJECT ORIENTED PROGRAMMING)
객체지향의 장점으로는 코드의 재사용성을 극대화시켜 개발 및 유지보수 과정에서 효율적입니다.
객체지향의 3대 특징으로는 추상화, 캡슐화, 상속, 다형성 있습니다. 

1) 추상화 
구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루며, 이 개념은 변수와 메소드를 정의하여 구현합니다. 
각 개체의 구체적인 개념에 의존하지 말고 추상적 개념에 의존해야 설계를 유연하게 변경할 수 있다.

2) 캡슐화 - 정보 은닉(information hiding)
필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것 클래스 외부에서 불필요한 데이터의 접근을 제한하여 올바른 값을 유지하도록 보호할 수 있습니다.

3) 일반화 관계(상속) - 
여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정 

4) 다형성
서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력

#### OOP의 5대 원칙(SOLID)
- S: 단일 책임 원칙(SRP, Single Responsibility Principle) 객체는 단 하나의 책임만 가져야 한다. 
- O: 개방-폐쇄 원칙(OCP, Open Closed Principle) 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다. 
- L: 리스코프 치환 원칙(LSP, Liskov Substitution Principle) 일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다. 
- I: 인터페이스 분리 원칙(ISP, Interface Segregation Principle) 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다. 
     특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다. 
- D: 의존 역전 원칙(DIP, Dependency Inversion Principle) 구체화(구현클래스)에 의해 의존하지 않고, 추상화(인터페이스)에 의존하여 설계한다. 
     의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.

#### Sprig을 사용하게 되는 목적 요소 
스프링은 IoC와 AOP를 지원하는 의 컨테이너 프레임워크
= 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

1. 스프링은 자바 및 JVM 환경의 대체언어들의 효율적이고 쉬운 엔터프라이즈 애플리케이션 개발 환경을 제공한다.
2. 스프링은 만들고자하는 애플리케이션의 요구사항과 목적에 따라 유연하게 적용시킬수 있습니다.
3. 스프링은 패키지들간의 순환 의존성이없는 깨끗한 프로젝트구성을 만들수 있다.
4. 스프링은 직관적인 API를 제공한다.
5. 스프링은 오픈소스로써 지속적인 업데이트가 되고 있으며 이전 버전들에대한 강력한 호환성을 지원한다.

#### (꼬리) ApplicationContext
BeanFactory : 스프링 빈을 관리하고 조회하는 역할을 담당한다. 
위의 기능을 모두 상속받아서 제공한다. + 부가기능
* 메시지소스를 활용한 국제화 기능 : 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
* 환경변수 : 로컬, 개발, 운영등을 구분해서 처리
* 애플리케이션 이벤트 : 이벤트를 발행하고 구독하는 모델을 편리하게 지원
* 편리한 리소스 조회 : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회


#### AOP란?
관심지향 프로그래밍 기법(AOP, Aspect Oriented Programming) 애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법입니다.
(참고) aop 와 ExceptionHandler -> https://ch4njun.tistory.com/220

#### 의존성이란?
의존관계를 가지는 상황 A 클래스가 B 클래스를 내부적으로 사용하는 경우를 말한다. B 클래스가 변경되면 기존의 A클래스에도 영향이 간다. 
이러한 의존성을 줄이기 위해 DI(Dependency Injection)를 사용합니다.

#### DI를 해야하는 이유?
DI, 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로 부터 필요한 객체를 받아서 사용하는 것이다. 이를 통해 객체간의 결합도를 줄이고 코드의 재활용성을 높여준다.
애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입

#### IOC에 대해 설명하시오. Inversion of Control = DI 컨테이너
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는것을 의미 즉 제어권을 컨테이너(프레임워크)가 가지며, 객체를 관리,생성을 책임지고, 의존성을 관리합니다.

#### PSA(Portable Service Abstraction)
환경의 변화와 관계없이 일관된 방식의 기술 접근 환경을 제공하려는 추상화 구조

### (꼬리) AOP란? 
관심지향 프로그래밍 기법(AOP, Aspect Oriented Programming)
애플리케이션의 핵심적인 기능과 부가적인 기능을 분리해 Aspect라는 모듈로 만들어 설계하고 개발하는 방법입니다.


### (꼬리)의존성 이란? 
의존관계를 가지는 상황 
A 클래스가 B 클래스를 내부적으로 사용하는 경우를 말한다.
B 클래스가 변경되면 기존의 A클래스에도 영향이 간다. 이러한 의존성을 줄이기 위해 DI(Dependency Injection)를 사용합니다.

### (꼬리) DI를 해야하는 이유?
DI, 의존성 주입은 필요한 객체를 직접 생성하는 것이 아닌 외부로 부터 필요한 객체를 받아서 사용하는 것이다.
이를 통해 객체간의 결합도를 줄이고 코드의 재활용성을 높여준다.

### (꼬리) IOC에 대해 설명하시오. Inversion of Control
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는것을 의미
즉 제어권을 컨테이너(프레임워크)가 가지며, 객체를 관리,생성을 책임지고, 의존성을 관리합니다.

###  (꼬리) @Autowired 의미는?
스프링컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다. 
기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다. 

###  (꼬리) 의존성 주입의 종류는?
의존성 주입의 종류로는 Constructor, Setter, Field 타입이 있습니다.

#### 필드 주입 방식의 단점은 아래와 같습니다.
1. 단일 책임((SRP)의 원칙 위반
필드 주입 망식은 일단 의존성을 주입하기 쉬워 @Autowired 선언 아래 3개든 10개든 막 추가할 수 있어, 많은 책임에 대한 위기감을 확인 불가.

이를 생성자 주입으로 구현 시, 
생성자에 필요한 파라미터가 많으면 지저분해 보인다. 이 때문에 필드 주입을 사용하는 경우도 많다. 그러나 지저분한 생성자는 실제로 우리에게 좋은 것을 말해준다. 이는 나쁜 코드 냄새이며, 클래스 설계 원칙 중 단일 책임 원칙(SRP: Single-Responsibility Principle)을 어기고 있다는 신호다. 즉, 리팩토링을 시작할 때임을 알려준다.

2. 의존성이 숨는다.
의존성 책임과 관리에 명확한 표현이 노출되어 표기되어야 한다. 하지만 필드 기반은 이러한 의존성 관련 정보를 클래스 내부에 숨겨서 가지고 있다.
DI(Dependency Injection) 컨테이너를 사용한다는 것은 클래스가 자신의 의존성만 책임진다는게 아닙니다. 제공된 의존성 또한 책임집니다. 그래서 클래스가 어떤 의존성을 책임지지 않을 때, 메서드나 생성자를 통해(Setter나 Contructor) 확실히 커뮤니케이션이 되어야만합니다. 하지만 Field Injection은 숨은 의존성만 제공해줍니다.

3. DI 컨테이너의 결합성과 테스트 용이성
DI 프레임워크의 핵심 아이디어는 관리되는 클래스가 DI 컨테이너에 의존성이 없어야합니다. 즉, 필요한 의존성을 전달하면 독립적으로 인스턴스화 할 수 있는 단순 POJO여야합니다. DI 컨테이너 없이도 유닛테스트에서 인스턴스화 시킬 수 있고, 각각 나누어서 테스트도 할 수 있습니다. 컨테이너의 결합성이 없다면 관리하거나 관리하지 않는 클래스를 사용할 수 있고, 심지어 다른 DI 컨테이너로 전환할 수 있습니다.하지만, Field Injection을 사용하면 필요한 의존성을 가진 클래스를 곧바로 인스턴스화 시킬 수 없습니다.

* POJO : 자바의 장점을 살리는 '오래된' 방식의 '순수한' 자바객체 
진정한 POJO란 객체지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다.

4. 불변성(Immutability)
Constructor Injection과 다르게 Field Injection은 final을 선언할 수 없습니다. 그래서 객체가 변할 수 있습니다.


#### 싱글톤 컨테이너
스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.
싱글톤 패턴을 적용하면 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를
공유해서 효율적으로 사용할 수 있다.

#### 스프링 빈의 이벤트 라이프사이클
스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료

* 초기화 콜백 @ostConstruct
* 소멸전 콜백 @PreDestroy 

최신 스프링에서 가장 권장하는 방법이다.
애노테이션 하나만 붙이면 되므로 매우 편리하다.
패키지를 잘 보면 javax.annotation.PostConstruct 이다. 스프링에 종속적인 기술이 아니라 JSR-250라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.
컴포넌트 스캔과 잘 어울린다.
유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다.

#### 스프링의 스코프 지원
* 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
* 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
* 웹 관련 스코프
1. request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다.
2. session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다.
3. application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다.

#### 스프링의 MVC 패턴 비교 
(참고) MVC1 VS MVC2 
https://chanhuiseok.github.io/posts/spring-3/

### Spring AOP / ExceptioHandler, ControllAdvice 
https://ch4njun.tistory.com/220

