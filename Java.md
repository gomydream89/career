# Java-Interview-QnA
자바 면접 질문과 답

### Q0. 자바(java)의 장단점을 설명하시오.
장 : 독립적/객체지향언어/메모리관리/오픈소스 /멀티스레드 / 동적로딩 
단 : 느린 속도/ 불편한 예외처리

자바의 가장 큰 장점은 JVM을 이용한 특정 운영체제에 종속되지 않은,  독립적 이라는 점입니다.  
자바에서 코드를 컴파일하면 바이트코드(.class) 형태로 출력됩니다. 이 바이트코드는 JVM에 런타임에 완벽한 기계코드로 변경되어 실행됩니다. 하나의 바이트코드를 가지고 서로다른 기계마다 해당 JVM만 설치되어있으면 다시 컴파일 할 필요 없이 나머지는 JVM에서 해당 기계에 맞도록 실행해줍니다. 
또한 GabargeCollector로 인해 별도의 메모리 관리가 필요 없으며 비지니스 로직에 집중 할 수 있습니다. 그리고 객제지향 프로그래밍에 최적화된 언어이며 오픈소스 라이브러리가 풍부하여 안정적인 어플리케이션을 쉽게 구현할 수 있습니다.
자바는 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에 실행되는 운영체제에 상관없이 멀티 스레드를 쉽게 구현할 수 있다. 애플리케이션이 실행될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성한다. 또한 유지보수 시 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다. 따라서 유지보수가 쉽고 빠르다.

자바의 단점은 JVM을 사용하는데서 발생하는데에 있습니다. JVM에 의해 기계어로 번역되고 실행되는 과정으로 인해 메모리 소모와 실행속도가 느립니다. 또한 프로그램 실행 시 발생할 수 있는 예외들에 대한 처리를 개발자가 처리해야 합니다. 


### (꼬리) JVM(java virtual machine)의 메모리 구조와 가비지 컬렉션(garbage collection)을 설명하시오.
JVM의 메모리 구조는 크게 class, stack, heap, native 메소드, PC 레지스터로 나뉩니다.

class 영역에는 클래스, 변수, 메소드, 상수, static 변수에 대한 정보가 저장됩니다.
stack 영역에는 메소드 호출에 따른 메소드를 위한 공간인 프레임(frame)이 생성되어 메소드 안에서 필요한 각종 값이 임시로 저장됩니다. 메소드의 수행이 끝나면 프레임별로 삭제가 진행됩니다.
heap 영역에는 new 연산자로 생성된 객체와 배열이 저장되는 공간입니다. 크게 permanent geration, new, old 영역으로 나뉩니다. permanent geration 영역에 생성된 객체들의 주소값이 저장됩니다. new 영역은 다시 eden, survivor 영역으로 나뉘어있습니다. eden에는 객체들이 최초로 생성되는 영역이며 suvivor는 eden 영역에서 참조되는 객체들이 저장되는 영역입니다. 마지막으로 old 영역은 new 영역에서 일정 시간 참조되고 있는 객체들이 저장되는 공간입니다.
native 메소드 영역은 자바 이외의 다른 언어에서 제공되는 메소드가 저장되는 영역입니다.
PC 레지스터 영역은 쓰레드가 생성될 때마다 생성되는 영역으로 쓰레드가 어떤 명령(현재 실행되는 부분의 명령과 주소)을 실행할지 저장합니다.

가비지 컬렉션은 크게 minor, major로 나뉩니다. minor에서는 new 영역을 대상으로 실행됩니다. 첫째로 new 영역 안의 eden 영역이 가득 차면 survivor1 영역으로 이동시킨 후 나머지 영역의 객체를 삭제합니다. 둘째로 eden 영역과 survivor1 영역이 기준치 이상으로 찼을경우 참조가 실제로 되고 있는지 검사 후 참조되는 객체만 survivor2 영역에 복사 후 나머지 영역의 객체를 삭제합니다. 마지막으로 일정시간 참조되고 있는 객체들을 old 영역으로 이동시킵니다.
major에서는 old 영역을 대상으로 실행됩니다. minor에 비해 시간이 오래 걸리며 old 영역이 가득 차, 프로세스가 정지될 가능성이 있는 경우 실행됩니다. old 영역에 있는 모든 객체를 검사하여 참조되지 않은 객체들을 한꺼번에 삭제합니다.

## JVM 
 Java Byte Code를 OS에 맞게 해석 해주는 역할
  Java compiler는 .java 파일을 .class 라는 Java byte code로 변환 시켜 줍니다. Byte Code 는 기계어가 아니기 때문에 OS에서 바로 실행되지 않습니다. 
  이때 JVM은 OS가 ByteCode를 이해할 수 있도록 해석 해줍니다. Byte Code는 JVM 위에서 OS상관없이 실행된다.
  JVM은 크게 Class Loader, Runtime Data Areas, Excution Engine 3가지로 구성

## Java 프로그램 실행과정
1. 프로그램 실행 시, JVM은 OS으로 부터 이 프로그램이 필요로 하는 메모리를 할당 받고 
   JVM은 이 메로리를 용도에 따라 여러 영억으로 나누어 관리
2. 자바 컴파일러가 자바 소소코드를 읽어들여 자바 바이트코드(.CLASS)로 변환시킨다.
3. Class Loader를 통해 class파일들을 JVM으로 로딩하낟.
4. 로딩된 class파일들은 RunTime Data Areas 에 배치되어 Excution Engine 을 통해 해석된다.

## JVM 구조
* Class Loader
RunTime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 됩니다.
* Runtime Data Areas
JVM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당 받은 메모리 공간을 말하며, Runtime Data Areas는 크게 5가지 영역으로 나눌 수 있습니다.
1) Heap 
 - 런타임 시 동적으로 할당하여 사용하는 영역이며, new 연산자로 생성된 객체 외 배열을 저장합니다. 
 - heap 영역에는  크게 permanent geration, new, old 영역으로 나뉩니다. permanent geration 영역에 생성된 객체들의 주소값이 저장됩니다. new 영역은 다시 eden, survivor 영역으로 나뉘어있습니다. eden에는 객체들이 최초로 생성되는 영역이며 suvivor는 eden 영역에서 참조되는 객체들이 저장되는 영역입니다. 마지막으로 old 영역은 new 영역에서 일정 시간 참조되고 있는 객체들이 저장되는 공간입니다. 
 
   - 프로그램 상에서 (class 이용해 instance 생성 시, Heap에 저장)
     new 연산자로 생성된 객체외 배열을 저장. 
     * New(Eden/Survivor) | Old | Permanent 
      permanent geration 영역에 생성된 객체들의 주소값이 저장됩니다. Class Loader에 의해 Load되는 클래스,메소드 등에 대한 Meta 정보가 저장되는 영역.
      new 영역은 다시 eden, survivor 영역으로 나뉘어있습니다. 
      eden에는 객체들이 최초로 생성되는 영역이며 suvivor는 eden 영역에서 참조되는 객체들이 저장되는 영역입니다. 
      마지막으로 old 영역은 new 영역에서 일정 시간 참조되고 있는 객체들이 저장되는 공간입니다. 

      Eden 영역에 객체가 가득차게 되면 첫번째 GC(minor Gc)가 발생되는데, Eden 영역의 값들을 survivor 1영역에 복사하고, 이영역을 제외한 나머지 영역의 객체를 삭제 
       

2) class Method Areas(= Static Area)
   - 클래스, 변수, 메소드, 상수, static 변수에 대한 정보의 바이트 코드등을 보관합니다. 
   - 모든 쓰레드가 공유하는 메모리 영역(클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드등을 보관)
     즉, 클래스 정보를 처음 메모리 공간에 올릴 떄 초기화 되는 대상을 저장하기 위한 메모리 공간. 
3) Native Method Stack
   - Java 외의 언어로 작성된 네이티브 코드들을 위한 저장되는 영역. stack.(JAVA Native Interface를 통해 바이트코드로 전환하여 저장)
     즉, 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역. 
4) Java Virtual Marchine Stack
   - stack 영역에는 메소드 호출에 따른 메소드를 위한 공간인 프레임(frame)이 생성되어 메소드 안에서 필요한 각종 값이 임시로 저장됩니다. 메소드의 수행이 끝나면 프레임별로 삭제가 진행됩니다.
   - Thread의 수행정보를 Frame(메소드만을 위한 공간)을 통해서 저장, Thread가 시작될 떄 생성되며, 각 Thread 별로 생성이 됨.
     임시로 할당 되었다가, 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역. 
     즉 메쏘드가 호출되면서 메쏘드와 몌소드 정보는 stack에 쌓이게 되며, 메쏘드 정보는 해당 메소뜨의 매개변수, 지역변수, 임시변수 그리고 어드레스(메소드 호출 한 주소)드을 저장하고, 메소드 종료 시 메모리 공간 사라진다.
5) PC Register
   - PC 레지스터는 Thread 별로 하나 씩 존재하며(시작될 떄 생성) 
     Thread가 어떤 부분을 명령으로 실행해야 하는 지에 대한 저장을 합니다. 
     현재 수행중인 Java Virtual Marchine Instuction 의 주소를 가지게 된다. 

* Execution Engine 
Load된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine입니다. 
Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Executin Engine에 의해 실행되며, 
실행 엔진은 자바 바이트 코드를 기계가 실행할 수 있는 형태로 변경하여 
명령어 단위(인터프리터)로 읽어서 실행합니다. 해당 방식은 한 줄 씩 수행하기 떄문에 느리다는 단점이 존재하며
이 단점을 보완하기 위해 도입된 방식은 Just In Time 컴파일러이다.
인터프리터 방식으로 실행하다 적절한 시점에 바이트코드 전체를 컾마일하여 네이티브 코드로 변경하고, 
이후에는 네이티브 코드로 직접 실행

## 메모리관리 
자바에서는 JVM이 프로그램 메모리를 관리한다. JVM은 가비지 컬렉션이란 프로세스를 통해 메모리를 관리하며, 
이 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거한다. 가비지 컬렉션은 실행 중인 JVM 내부에서 일어난다.

1) Minor GC
minor에서는 new 영역(Eden/Survivor)을 대상으로 실행됩니다. 
첫째로 new 영역 안의 eden 영역이 가득 차면 survivor1 영역으로 이동시킨 후 나머지 영역의 객체를 삭제합니다. 
둘째로 eden 영역과 survivor1 영역이 기준치 이상으로 찼을경우 참조가 실제로 되고 있는지 검사 후 참조되는 객체만 
survivor2 영역에 복사 후 나머지 영역의 객체를 삭제합니다. 마지막으로 일정시간 참조되고 있는 객체들을 old 영역으로 이동시킵니다.

2) Major GC
major에서는 old 영역을 대상으로 실행됩니다. old 영역에 있는 모든 객체를 검사하여 참조되지 않은 객체들을 한꺼번에 삭제합니다.
minor에 비해 시간이 오래 걸리며 실행 중 프로세스가 정지된다. 이것을 STOP-THE-WORLD라고 하는데 
Major GC가 발생하면 GC를 실행하는 스레드를 제외한 나머지 스레드는 모두 작업을 멈추며, GC 작업을 완료한 이후에야 중단했던
작업을 다시 시작한다. 
old 영역이 가득 차, 프로세스가 정지될 가능성이 있는 경우 실행됩니다. 

## 참고. JDK & JRE
JDK는 자바 개발 키트이다.(JDK: Java Development Kit)
JDK = JVM + 라이브러리 API + 컴파일러
JRE는 자바 실행 환경이다.(JRE: Java Runtime Environment)
JRE = JVM + 라이브러리 API
자바 프로그램을 개발하려면 JDK를 사용하면 되고, 개발된 프로그램을 실행만 한다면 JRE만 설치하면 된다.

### (꼬리). JDK와 SDK에 대해서 설명하시오. 
JDK는 개발자가 자바 기반 애플리케이션 개발을 위해 다운로드하는 소프트웨어 패키지

👉🏻 JDK는 자바 개발 키트(Java Development Kit)의 약자입니다. 이것은 자바 애플리케이션을 구축하기 위한 핵심 플랫폼 구성 요소입니다. JDK는 자바 가상 머신(Java Virtual Machine, JVM), 그리고 자바 런타임 환경(Java Runtime Environment, JRE)과 함께 자바 프로그래밍에 사용되는 3대 핵심 기술 패키지 가운데 하나 입니다. 
JDK는 개발자들이 JVM과 JRE에 의해 실행되고 구동될 수 있는 자바 프로그램을 생성할 수 있게 해주는 것입니다. JDK는 자바 기반 소프트웨어를 개발하기 위한 도구들로 이뤄진 패키지인 반면, JRE는 자바 코드를 실행하기 위한 도구들로 구성된 패키지입니다. 


### (꼬리). 자바 라이브러리란 무엇이고? 정적 라이브러리와 공유 라이브러리 차이점에 대해 설명하시오.
유용한 기능을 하는 Class 를 묶음 , 특정 기능이 필요할 떄 호출해서 쓰는 도구 모음 

Java에서는 미리 자주사용되고 유용한 기능을 하는 class들을 만들어 놓고 제공을 합니다. 이때 이 클래스들을 관련된 기능별로 분류하여 패키지단위로 묶어서 관리하는데 이 패키지 파일을 라이브러리라고 합니다. Java API는 이러한 클래스들의 코드를 문서로 제공하는 것입니다. API는 Application Programming Interface의 약자입니다. 즉, 응용 프로그램에서 사용할 수 있도록 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 말합니다. API는 프로그램과 또 다른 프로그램을 연결해주는 일종의 다리라고 할 수 있습니다.

👉🏻 정적 링크 라이브러리(Static Link Library)는 .lib으로 표현하며 컴파일 시에 함수가 실행파일에 연결됩니다. 실행 파일에 함수의 코드가 복사되기 때문에 실행파일의 크기가 커지는 단점이 있지만 실행 파일은 완전한 단독 실행 파일이 됩니다. 실행파일에 함수의 코드가 포함되어 있기 때문에 컴파일이 끝나면 lib 파일이 없어도 프로그램을 실행 할 수있습니다.

👉🏻 동적 링크 라이브러리(Dynamic Link Library)는 .dll로 표현하며 정적라이브러리처럼 컴파일 시에 함수가 연결되는 방식이 아닌 런타임시에 함수가 실행파일에 연결됩니다. 실행파일에는 호출할 함수의 정보만 포함되고 실제 함수 코드는 복사되지 않으므로 실행 파일의 크기가 작아집니다. 하지만 실행 파일은 함수에 대한 정보만 가지고 있을 뿐 실제 코드를 가지고 있지 않기 때문에 프로그램 실행시에는 dll 파일이 항상 존재해야 합니다.


### Q1. 기본 자료형(primitive data type)과 참조 자료형(reference data type)에 대해 설명하시오.
기본 자료형은 byte, short, int, long, float, double, char, boolean이 존재합니다. 기본 자료형으로 생성한 변수에는 값 자체가 저장됩니다. 사용전에 반드시 선언되어야하며 OS에 따라 자료형의 길이가 변하지 않고 null 값을 갖을수 없는 특징이 있습니다.

참조 자료형은 class, interface, array, enum이 존재합니다. 참조 자료형으로 생성한 변수에는 객체의 주소값이 저장됩니다. 생성자를 이용하여 새로운 객체의 주소를 가리키거나 null 값을 이용하여 해제할 수 있습니다.

### (꼬리) 접근제어자(access modifier)에 대해 설명하시오.
변수 메소드에 설정하는 키워드 / 접근영역을 제한 

접근제어자는 객체지향 프로그래밍에서 클래스의 멤버 변수 또는 메소드에 설정하는 키워드로 접근 영역을 제한하는데 사용합니다. public, default, protected, private이 존재합니다. 접근제어자를 사용하지 않았을 경우에는 기본적으로 default를 갖습니다. public은 접근 제한을 하지 않음을 의미합니다. private는 해당 클래스에서 생성된 객체들만 접근 가능합니다. .default는 같은 패키지 내에서만 접근이 가능함을 의미합니다. protected는 같은 패키지 내 혹은 다른 패키지의 자식 클래스에서 접근이 가능함을 의미합니다. 


### Q2. 객체지향 프로그래밍(object-oriented programming)에 대해 설명하시오.
실세계를 모델링하여 소프트웨어를 개발 
장점 : 코드의 재사용성 / 유지보수 용이성

객체지향의 3대 특징으로는 추상화, 캡슐화, 상속, 다형성 있습니다. 객체지향의 장점으로는 코드의 재사용성을 극대화시켜 개발 및 유지보수 과정에서 효율적입니다. 

추상화 - 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루며, 이 개념은 변수와 메소드를 정의하여 구현합니다. 
         각 개체의 구체적인 개념에 의존하지 말고 추상적 개념에 의존해야 설계를 유연하게 변경할 수 있다.

캡슐화 - 정보 은닉(information hiding): 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것 
         클래스 외부에서 불필요한 데이터의 접근을 제한하여 올바른 값을 유지하도록 보호할 수 있습니다.

일반화 관계(상속) - 객체지향 프로그래밍 관점에서 상속 관계라 한다. 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정,
                   공통된 속성이나 행위를 하나에 클래스에 모아서 상속받아서 자식 클래스가 사용한다

다형성 - 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력


### (꼬리)) 클랙스, 객체, 인스턴스의 차이 
1. 객체(Object)
소프트웨어 세계에 구현할 대상
2. 클래스(Class)
객체를 만들어 내기 위한 구체적인 설계도 혹은 틀 (연관되어 있는 변수와 메서드의 집합)
3. 인스턴스
설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.


### (꼬리)) 응집도와 결합도에 대해 설명하시오.
응집도(Cohesion) - 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다.
결합도(Coupling) - 어떤 기능을 실행하는 데 다른 클래스나 모듈들에 얼마나 의존적인지를 나타낸다.

낮은 결합도를 유지 : 높은 결합도는 많은 문제를 야기시킵니다. 한 클래스가 변경이 발생하면 변경된 클래스의 비밀에 의존하는 다른 클래스들도 변경해야 할 가능성이 커진다는 뜻이다.

### (꼬리)) 다형성(polymerphism)에 대해 설명하시오.
객체지향 프로그래밍에서 하나의 메소드나 클래스가 다양한 방법으로 동작하게하는 요소를 말합니다.  
대표적으로 메소드 오버라이딩, 오버로딩이 있습니다.

메소드 오버라이딩은 자식 클래스에서 부모 클래스의 메소드를 새롭게 재정의하는 것을 말합니다. 메소드의 선언부는 같은 형태이지만 몸체에서 다른 역할을 수행하도록 합니다. 같은 이름과 형식의 메소드라도 클래스에 따라 다른 기능을 부여하는 기능을 갖습니다. 상속의 개념을 이용하여 부모 클래스의 기능을 자식 클래스에서 물려받거나 재정의를 통해 부모와 자식의 다른 기능을 구현하는 다형성까지 포함합니다.

메소드 오버로딩은 하나의 클래스에서 같은 이름을 가졌지만 인자의 종류나 숫자가 다른 메소드를 구현하는 것을 말합니다. 같은 기능을 수행하지만 다른 인자를 수행하는 메소드를 정의할 경우 이름을 동일하게 묶어주는 기능을 수행합니다.

### (꼬리)) 피터코드의 상속 규칙 
상속의 오용을 막기 위해 상속의 사용을 엄격하게 제한하는 규칙들

5가지 규칙 중 어느 하나라도 만족하지 않는다면 상속을 사용해서는 안된다.
1. 자식 클래스와 부모 클래스 사이는 ‘역할 수행’관계가 아니어야 한다.
2. 한 클래스의 인스턴스는 다른 자식 클래스의 객체로 변환할 필요가 절대 없어야 한다.
3. 자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다.
4. 자식 클래스가 단지 일부 기능을 재사용할 목적으로 유틸리티 역할을 수행하는 클래스를 상속하지 않아야 한다.
5. 자식 클래스가 ‘역할’, ‘트랜잭션’, ‘디바이스’ 등을 특수화해야 한다.

### (꼬리)) OOP의 5대 원칙(SOLID)
S: 단일 책임 원칙(SRP, Single Responsibility Principle)
객체는 단 하나의 책임만 가져야 한다.
O: 개방-폐쇄 원칙(OCP, Open Closed Principle)
기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.
L: 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.
I: 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다. 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다. 
D: 의존 역전 원칙(DIP, Dependency Inversion Principle)
구체화(구현클래스)에 의해 의존하지 않고, 추상화(인터페이스)에 의존하여 설계한다.
의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다.

### Q3. 추상 클래스(abstract class)와 인터페이스(interface)에 대해 설명하시오.
추상 클래스는 abstract 키워드를 이용하여 미완성 메소드 즉, 형태만 정의해 놓고 몸체는 없는 상태를 포함하고 있는 클래스를 의미합니다. 추상 클래스는 상속에 큰 의미를 두고 있습니다. 클래스이기 때문에 extends 키워드를 이용하여 상속을 진행하며 이런 추상 클래스를 상속받은 자식 클래스에서는 반드시 미완성 메소드를 재정의해야합니다.

인터페이스는 추상 클래스보다 추상화 정도가 높은 상태를 정의할 때 사용합니다. 인터페이스는 기능의 재정의에 큰 의미를 두고 있습니다. 멤버 변수와 일반 메소드를 가질 수 없으며 오직 상수와 추상 메소드만을 선언할 수 있습니다. implements 키워드를 이용하여 상속을 진행하며 자식 클래스에서 반드시 메소드를 재정의해야합니다. 그 밖에 인터페이스는 클래스에서 지원하지 않는 다중상속이 가능합니다.

다만 JAVA8부터는  interface에서 static과 default 메서드를 사용할 수 있습니다.


### Q4. final 키워드의 다양한 쓰임새를 설명하시오.
변수나 메서드 또는 클래스가 '변경불가능'하도록 만드는 것입니다. 

변수에 final 키워드를 사용하면 해당 변수를 상수화 할 수 있습니다. final 키워드가 붙어있는 변수는 초기화만 가능하며 이후 새로운 값으로 변경이나 재할당이 불가능합니다.
다음으로 클래스에 final 키워드를 사용하면 해당 클래스를 상속할 수 없습니다. 이 경우 abstract 키워드와 기능적인면에서 충돌이 있기 때문에 함께 사용할 수 없습니다.
마지막으로 클래스의 메소드에 final 키워드를 사용하면 해당 메소드를 오버라이딩 할 수 없습니다.

### (꼬리)) finally/finalize
finally 키워드
개념: try/catch 블록이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용한다.
finalize() 메서드
개념: 쓰레기 수집기(GC, Garbage Collector)가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출된다.


### Q5. static 키워드의 쓰임새를 설명하시오.
클래스 내부의 메소드나 멤버 변수에 static 키워드를 사용하면 하나의 인스턴스에 속하지 않고 해당 클래스로부터 생성된 모든 인스턴스가 공통으로 공유하는 메소드와 변수로 변경됩니다.
클래스 로딩 시에 생성되어, 객체가 생기기전에 사용이 가능하다. 


### Q06. 객체의 직렬화(serialization)에 대해 설명하시오.
객체에 저장되어있는 데이터를 스트림(파일로 저장 혹은 네트워크를 이용하여 전송)에 바로 쓰기 위해 연속적인 데이터로 변환하는 것을 말합니다. 반대로 스트림으로부터 데이터를 읽어 객체로 변환하는 과정은 역직렬화라고 합니다. io 패키지내에 구현되어있는 Serializable 인터페이스를 상속 받으면 직렬화가 가능한 클래스로 변경할 수 있습니다. 직렬화를 시키고자하는 클래스에 직렬화가 안되는 객체가 포함되어있을 경우 transient 키워드를 이용하여 해당 객체를 직렬화 대상에서 제외시킬수 있습니다.

### Q07. 자바의 형변환 규칙은 어떻게 되는지 예를 들어 설명하시오.
형변환에는 크게 2가지가 존재합니다. 첫번째로 묵시적 형변환으로 자바에서는 작은 단위를 큰 단위로 바꾸는 경우 묵시적 형변환을 지원합니다. 예를들어 상속관계에서 하위 객체를 상위 객체로 변환하거나 int형 변수를 double형 변수로 변환할 수 있습니다. 두번째로 명시적 형변환으로 큰 단위에서 작은 단위로 바꾸는 경우 명시적 형변환을 프로그래머가 정의해주어야 합니다. 이 경우 데이터의 일부가 유실될 수 있습니다. 예를들어 long 변수에 저장되어 있는 값을 int 변수로 변환하는 경우 (int) 키워드를 사용하는 방식입니다. 기타 산술, 논리, 참조 자료형 사이에서는 형변환이 불가능합니다.

### (꼬리)  래퍼 클래스(wrapper class)에 대해 설명하시오.
기본 자료형으로 표현된 데이터를 참조 자료형으로 만들어야 할 경우 래퍼 클래스를 사용합니다. 보통 특정 메소드에서 참조 자료형을 인자로 받거나, 기본 자료형이 아닌 객체 자료형으로 저장해야할 경우, 객체간 비교가 필요할 경우에 사용합니다.
Autoboxing, Unboxing 개념을 사용하는데요, 오토박싱의 경우 명시적으로 기본 자료형을 래퍼클래스로 감싸주지 않아도 박싱(Wrapper-포장)해주는 것입니다. 언박싱은 그 반대의 경우입니다. 명시적으로 기본 자료형으로 변환하지 않아도 포장을 풀어줍니다. 


### Q08. String, StringBuffer, StringBuilder에 대해서 설명하시오.
String은 문자열을 처리하는 자바의 대표적인 클래스입니다. String 클래스는 한번 생성되면 변경이 불가능한 immutable 성격을 가지고 있습니다. String 클래스가 immutable한 이유는 변경이 적고 참조만 많은 경우 혹은 여러개의 쓰레드에서 공유하는 문자열일 경우 별다른 동기화를 구현하지 않고 안전하게 공유될 수 있다는 장점있기 때문입니다. 하지만 문자열을 변형하는 경우가 많은 경우(자르거나 이어붙이기) 매번 새로운 String 객체가 생성되기 때문에 메모리와 속도측면에서 비효율적입니다. 따라서 String 클래스는 변경이 적고 단순 참조만 많은 경우에 사용합니다.

StringBuffer 클래스와 StringBuilder 클래스는 새로운 객체를 생성하지 않고 기존 문자열을 변경합니다. 단, StringBuilder의 경우 쓰레드의 동기화를 지원하지 않기 때문에 쓰레드에서 사용하기 위해서는 StringBuffer 클래스를 이용해야합니다. 하지만 속도는 동기화를 처리하지 않는 StringBuilder 클래스가 동기화를 처리하는 StringBuffer 클래스보다 빠르기 때문에 쓰레드를 사용하지 않는 환경에서는 StringBuilder 클래스를 사용하는편이 유리합니다.

### (꼬리) String 클래스의 intern 메소드와 상수 풀(constant pool)에 대해 설명하시오.
자바에서 쓰이는 모든 String 객체는 상수 풀에서 관리됩니다. 상수 풀은 객체가 생성되는 영역인 heap의 permanent generation 영역에 생성되어 자바 프로세스가 종료될 때 까지 함께합니다. 상수 풀을 이용하여 String을 관리하는 이유는 중복 문자열에 대한 효율적인 메모리 관리 때문입니다. 같은 문자열이 이미 존재하는데 다시 동일한 문자열이 상수 풀에 삽입되려는 경우 삽입을 위해 heap에 생성되었던 문자열을 해제하고 상수 풀에서 관리하는 래퍼런스로 반환해줍니다. 이렇게 함으로서 동일한 문자열로 인해 메모리가 낭비되는 현상을 해결합니다.

String 클래스의 intern 메소드는 heap 영역에 있는 문자열 객체를 상수 풀로 이전시키는 메소드입니다. intern 메소드는 실행 후 해당 문자열과 동일한 문자열이 없다면 해당 객체를 상수 풀에 등록하고 heap 영역에서 해제 후 래퍼런스 값을 반환합니다. 만약 해당 문자열과 동일한 문자열이 있다면 해당 객체를 heap 영역에서 해제 후 상수 풀에 있는 해당 문자열의 래퍼런스 값을 반환해줍니다.

String 객체를 생성하는 방법에는 크게 2가지가 있습니다. 첫번째로 리터럴("")을 이용한 방법입니다. 이 경우 내부적으로 String 생성자로 객체를 heap 영역에 생성한 후 intern 메소드가 호출되어 상수 풀에 해당 객체를 등록하는 과정을 거칩니다. 두번째로 String 생성자를 이용하는 방법이 있습니다. 이 경우 heap의 어떤 영역에 단순한 인스턴스로 저장합니다. 이 경우 상수 풀에 등록되지 않습니다. 후에 명시적으로 intern 메소드를 호출하여 상수 풀로 옮겨줄 수 있습니다.

상수 풀에 등록되어있는 문자열 객체의 경우 == 연산자를 이용하면 바로 두 문자열이 같은지 boolean 값으로 확인할 수 있습니다. 하지만 String 생성자를 이용해 heap의 한 영역에 생성된 문자열 객체의 경우 == 연산자를 이용하여 바로 두 문자열이 같은지 비교할 수 없습니다. 두 문자열 객체의 래퍼런스 값이 다르기 때문입니다. 이 경우 String 클래스의 equals를 이용하여 두 문자열의 값을 비교할 수 있습니다.


### Q9. 컬렉션(collection) 클래스에서 제네릭을 사용하는 이유를 설명하시오.
컬렉션 클래스에서 제네릭을 사용하면 컴파일러는 특정 타입만 포할될 수 있도록 컬렉션을 제한합니다. 컬렉션 클래스에 저장하는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일타임에 잡아낼 수 있도록 도와줍니다.
컬렉션에는 어떤 자료를 담을지 알 수 없으므로 최상위 객체인 Object형태로 저장되고 관리되도록 설계되어 있다. 하지만, 의도하지 않은 자료형이 담기는 경우도 발생하게 된다. 이 때의 오류는 컴파일시에는 알 수가 없고 실행을 시켜보아야만 알 수 있다는 것이 문제점이었다. 담긴 자료를 꺼낼 떄, 형변환 시, 타입 에러 발생.

제너릭 타입을 사용하면 프로그래머가 원하는 객체의 타입을 명시해서 의도하지 않은 객체는 저장될 수 없도록 컴파일시에 오류를 확인할 수있게 된다. ex) <T extends Number) 한정적 타입 매개변수

* 제네릭을 사용할 수 없는 경우 ? 제네릭으로 배열을 생성할 수 없다. 또한 static 변수에도 제너릭을 사용할 수 없다.

제네릭이란? 모든 종류의 타입을 다룰 수 있도록 일반화된 타입 매개 변수(generic type)로 클래스나 메서드를 선언하는 기법
클래스를 정의할때 데이터 타입을 확정하지 않고 인스턴스를 생성할 떄 데이터 타입을 지정하는 기능이 제네릭.
-> 형 변환이 필요없고, 타입안전성이 보장된다. 또한 코드의 재사용성이 높아진다.



### (꼬리) 컬렉션(collection) 클래스의 대표 인터페이스를 설명하시오.
컬렉션 클래스는 크게 list, set, map이 있습니다.
list는 순차적인 데이터를 저장하며 중복을 허용하는 자료구조입니다. arraylist, linkedlist, stack, vactor가 하위 클래스로 존재합니다.
set은 순서를 유지하지 않고 데이터의 중복만 허용하지 않는 자료구조입니다. hashset, treeset이 하위 클래스로 존재합니다.
map은 키와 값으로 이루어진 데이터를 순서를 유지하지 않고 키의 중복만 허용하지 않는 자료구조입니다. hashmap, treemap, hashtable, properties가 하위 클래스로 존재합니다.

### (꼬리). Array(배열)과 List의 차이점은 무엇인지 설명하시오.
👉🏻 Array(배열)은 다수의 데이터를 묶어 효율적인 관리가 가능하나, 정의와 동시에 길이를 지정하여 길이를 바꿀 수 없는 정적 자료형 입니다.
데이터에 접근하기 위한 인덱스가 존재합니다. 이 인덱스를 통해 데이터를 가져오기 때문에 조회 속도가 빠릅니다. 그러나 데이터의 위치가 인덱스와 맵핑되어 고정되므로 추후 데이터가 삭제되는 경우 배열의 빈 부분의 메모리가 낭비됩니다. 이러한 이유로 배열의 해당 인덱스에 데이터가 존재하는지 파악하는 로직이 추가적으로 필요합니다. 

👉🏻 List는 배열이 가진 인덱스의 장점을 버리고 대신 빈틈없이 데이터를 적재하는 장점을 취한 자료형입니다. 순서가 있으며 중복이 허용됩니다. 주로 ArrayList나 LinkedList와 같은 리스트를 사용합니다. 리스트는 자동으로 엘리먼트를 수용할 수 있는 크기가 조정되고, 리스트 내의 엘리먼트의 실제 개수를 알려줍니다. 


### 10. Git이 무엇인지 설명하고 프로젝트에서 깃랩를 사용했다면 어떤 식으로 기여했는지 설명하시오.
git이란 형상 관리 도구 중 하나입니다. 소프트웨어를 개발하는 기업의 핵심 자산인 소스코드를 효과적으로 관리할 수 있게 해주는 공개 소프트웨어입니다. 현재 수행중인 KT&G 신경작 시스템 개발에서는 
GIT LAB을 이용하여 개발을 수행중입니다. 각 팀원 별로 브랜치를 생성하여 체계적인 Pull Request와 merge를 통해 프로젝트를 업데이트 했습니다. 기본적인 pull, push, commit을 사용하여 항상 최신 버전으로 유지할 수 있도록 운영했습니다. 

+) Git의 장점
1. 소스코드를 주고 받을 필요 없이, 같은 파일을 여러명이 동시에 작업하는 병렬 개발이 가능하다.
2. 브랜치를 통해 개발한 뒤, 본 프로그램에 합치는 방식(merge)으로 개발을 진행할 수 있다.
3. 분산 버전관리이기 때문에 인터넷이 연결되지 않은 곳에서도 개발을 진행할 수 있으며 중앙 저장소가 날아가버려도 다시 원상복구 할 수 있다.
4. 팀 프로젝트가 아닌, 개인 프로젝트일지라도 Git을 통해 버전 관리를 하면 체계적인 개발이 가능해지고, 프로그램이나 패치를 배포하는 과정도 간단해진다. (pull을 통한 업데이트, patch 파일 배포) 



### Q11. Java 8의 변경사항에는 무엇이 있는지 설명하시오.
Java 8 버전에는 람다 표현식(Lamda expressions), 스트림 API(Stream API), java.time 패키지 등 이 주목할만한 특징입니다.

1. 람다 표현식은 메소드를 하나의 식으로 표현한 것입니다. 식별자 없이 실행할 수 있는 함수 표현식을 의미하며, 따라서 익명 함수(Anonymous function)라고도 부릅니다. 
-> 함수형 인터페이스를 통해서만 사용할 수 있다. [단 하나의 메소드만이 선언된 인터페이스] @FunctionalInterface 어노테이션으로 메소드 추가 에러 방지.

2. 스트림 API는 저장된 데이터에 접근하는 경우 반복문이나 반복자를 사용하여 매번 코드를 작성하는 불편한 점이 있었는데 이러한 문제점을 보완하기 위해서 도입된 방법입니다.  데이터를 추상화하여 다루므로, 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공합니다. 따라서 배열이나 컬렉션 뿐만 아니라 파일에 저장된 데이터도 모두 같은 방법으로 다룰 수 있습니다.
-> 스트림의 특징 (데이터나 소스를 변경하지 않는다/일회용이다/작업을 내부반복으로 처리한다)
-> 스트림의 연산
* 중간 연산: 연산결과를 스트림으로 반환하기 때문에 중간 연산을 연속해서 연결할 수 있다.
핵심 메서드: map() -> 스트림의 요소에 저장된 값 중에서 원하는 필드로만 뽑아내거나(filter) 특정 형태로 변환해야 할 때 사용된다.
            flatMap() -> 스트림의 요소가 배열이거나 map()의 연산결과가 배열인 경우, 즉 스트림의 타입이 Stream<T[]>인 경우, Stream로 변환(Stream<T[]> -> Stream로 변환)
* 최종 연산: 스트림의 요소를 소모하면서 연산을 수행하기 때문에 단 한번만 연산이 가능하다.
핵심 메서드: reduce() -> 스트림의 요소를 줄여나가면서 연산을 수행하고 최종결과를 반환한다.
            reduce 메소드는 총 세 가지의 파라미터를 받을 수 있습니다.
                  accumulator : 각 요소를 처리하는 계산 로직. 각 요소가 올 때마다 중간 결과를 생성하는 로직.
                  identity : 계산을 위한 초기값으로 스트림이 비어서 계산할 내용이 없더라도 이 값은 리턴.
                  combiner : 병렬(parallel) 스트림에서 나눠 계산한 결과를 하나로 합치는 동작하는 로직.
            collect() -> Collector 타입의 인자를 받아서 처리
                  List<String> collectorCollection =
                        productList.stream()
                          .map(Product::getName)
                          .collect(Collectors.toList());
 
3. java.time 패키지는 Calendar 클래스의 문제점을 보완하기 위해 도입되었습니다. Calendar 인스턴스는 불변객체가 아니라서 값이 수정될 수 있었고, 윤초와 같은 특별한 상황을 고려하지 않았으며 월(month)를 나타낼 때 1월부터 12월을 0~11까지로 표현해야 하는 불편함이 있었습니다. 


### Q12. 자바에서 쓰레드를 구현하기 위한 2가지 방법을 간단하게 설명하시오.
lang 패키지내에 구현되어있는 Thread 클래스를 상속받거나 Runnable 인터페이스를 상속받아 run 메소드를 재정의하여 구현합니다.

### (꼬리). Thread 란? 
스레드(Thread)란 프로세스(Process) 내에서 실제로 작업을 수행하는 주체를 의미합니다.

장점 
1. 시스템 자원 소모 감소(자원의 효율성 증대)
2. 시스템 처리량 증가(처리 비용 감소) - 스레드 사이의 작업량이 작아 Context Switching**이 빠름
3. 간단한 통신 방법으로 인한 프로그램 응답 시간 단축 - 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담의 적음

단점
1. 주의 깊은 설계가 필요
2. 디버깅이 까다롭다.
3. 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다. 
4. 멀티 스레드의 경우 자원 공유의 문제가 발생한다.(동기화** 문제)

### (꼬리). 자바에서 쓰레드의 동기화(synchronized)와 데드락(deadlock)을 설명하시오.
2개 이상의 쓰레드가 하나의 공유 자원에 접근하여 값을 변경하려 할 때, 동기화를 적용하지 않으면 값이 올바르지 못하게 변경될 가능성이 있습니다. 따라서 공유 변수에 synchronized 키워드를 사용하거나 블록을 설정하여 하나의 쓰레드가 공유 자원을 점유하고 있을 경우 다른 쓰레드가 잠시 대기상태에 머무르도록 할 수 있습니다.

데드락은 다음과 같은 예를 들어 설명할 수 있습니다. a 쓰레드가 foo라는 공유 변수에 락을 걸어둔 상태로 작업을 진행하고 있고, b 쓰레드가 bar라는 공유 변수에 락을 걸어둔 상태로 작업을 진행하고 있다고 가정합니다. 여기서 a 쓰레드에서 bar 공유 변수가 필요한 코드를 만났지만 bar는 이미 b 쓰레드가 선점하고 있으므로 a 쓰레드는 대기 상태로 변경됩니다. 동시에 b 쓰레드에서도 foo 공유 변수가 필요한 코드를 만났다고 가정하면 foo는 이미 a 쓰레드가 선점하고 있으므로 b 쓰레드도 역시 대기 상태로 변경됩니다. 이렇게 두 쓰레드가 모두 대기 상태 계속 머무르게 되는 현상을 말합니다.


### Q15. 싱글톤 패턴과 문제점을 설명하시오.
클라이언트 요청에 따라 객체를 매번 생성하는 것이 아닌, 만들어진 객체를 공유해서 효율적으로 사용하여 메모리 낭비를 방지.


* 문제점
1. 의존관계상 클라이언트가 구체 클래스에 의존합니다.(DIP 위반)
2. 구체 클래스에 의존시 OCP 위반 가능성 높다.
3. Private 생성자로 자식 클래스를 만들기 어렵다.
4. 테스트가 어려우며, 내부 속성을 변경하거나 초기화 하기 어렵다.
5. 유연성이 떨어진다. 
6. 멀티 쓰레드 환경 시, 동기화 처리를 안하는 경우 인스턴스가 두개 생성될 가능성 존재. 

* 안전한 싱글톤 클래스 이용 
1. Thread safe Lazy initialization (게으른 초기화)
private static으로 인스턴스 변수를 만들고 private 생성자로 외부에서 생성을 막았으며 synchronized 키워드를 사용해서 thread-safe하게 만들었다.
하지만 synchronized 특성상 비교적 큰 성능저하가 발생하므로 권장하지 않는 방법이다.
    private static ThreadSafeLazyInitialization instance;
    private ThreadSafeLazyInitialization(){}
    public static synchronized ThreadSafeLazyInitialization getInstance(){
        if(instance == null){
            instance = new ThreadSafeLazyInitialization();
        }
        return instance;
    }
synchronizeds는 공유 데이터를 사용하는 코드 영역을 임계 영역으로 지정해놓고, 공유 데이터(객체)가 가지고 있는 lock을 
획득한 단 하나의 스레드만 이 영역 내의 코드를 수행 할 수 있게 한다. 즉 스레드의 동기화 
2. Thread safe lazy initialization + Double-checked locking
getInstance()에 synchronized를 사용하는 것이 아니라 첫 번째 if문으로 인스턴스의 존재여부를 체크하고 두 번째 if문에서 다시 한번 체크할 때 동기화 시켜서 인스턴스를 생성하므로 thread-safe하면서도 처음 생성 이후에 synchonized 블럭을 타지 않기 때문에 성능저하를 완화했다.
    public static ThreadSafeLazyInitialization getInstance(){
        if(instance == null){
            synchronized (ThreadSafeLazyInitialization.class) {
                if(instance == null)
                    instance = new ThreadSafeLazyInitialization();
            }
        }
        return instance;
    }
3. Initialization on demand holder idiom (holder에 의한 초기화)
클래스안에 클래스(Holder)를 두어 JVM의 Class loader 매커니즘과 Class가 로드되는 시점을 이용한 방법
public class Something {
    private Something() {
    }
 
    private static class LazyHolder {
        public static final Something INSTANCE = new Something();
    }
 
    public static Something getInstance() {
        return LazyHolder.INSTANCE;
    }
}
holder안에 선언된 instance가 static이기 때문에 클래스 로딩시점에 한번만 호출될 것이며 final을 사용해 다시 값이 할당되지 않도록 만든 방법.



### Q16. @Lombok 애노테이션에 대해 설명하시오.
Lombok은 Annotation을 이용해 Getter, Setter, Builder등을 만들어주는 라이브러리이다.
 @NoArgsConstructor 어노테이션은 파라미터가 없는 기본 생성자를 생성해주고, @AllArgsConstructor 어노테이션은 모든 필드 값을 파라미터로 받는 생성자를 만들어줍니다. 
 마지막으로 @RequiredArgsConstructor 어노테이션은 final이나 @NonNull인 필드 값만 파라미터로 받는 생성자를 만들어줍니다.

### (꼬리) @Builder 패턴 
Builder 패턴의 목적은 유동적으로 필드에 값을 세팅하고, 객체를 생성한 후, 변경불가능 상태로 만드는 것이에요.
각 인자가 어떤 의미인지 알기 쉽다. 한 번에 객체를 생성하므로 객체 일관성이 깨지지 않는다.

### (꼬리) CommandLineRunner 사용 이유?
스프링 부트 애플리케이션 구동 시점에 특정 코드 실행하기 위해 .
CommandLineRunner 인터페이스는 구동 시점에 실행되는 코드가 자바 문자열 아규먼트 배열에 접근해야할 필요가 있는 경우에 사용합니다. 다음과 같이 CommandLineRunner 인터페이스를 구현한 클래스에 @Component 어노테이션을 선언해두면 컴포넌트 스캔이되고 구동 시점에 run 메소드의 코드가 실행됩니다.

### Q17. 과제 중, 왜 BigDecimal을 사용하였는지 서령하시오. 
BigDecimal은 Java 언어에서 숫자를 정밀하게 저장하고 표현할 수 있는 유일한 방법이며, 
금융권 계정계 운영 업무 수행 할떄, 오차 없이 실수를 표현하기 위해 해당 자료형을 사용 

### Q18. Native Query 사용 이유 
JPQL은 표준 SQL이 지원하는 대부분의 문법과 SQL 함수들을 지원하지만
특정 데이터베이스에 종속적인 기능은 지원하지 않음 (Ex.

- 특정 데이터베이스만 지원하는 함수, 문법, SQL 쿼리 힌트
- 인라인 뷰, UNION, INTERSECT
- 스토어드 프로시저


다양한 이유로 JPQL을 사용할 수 없을 때,
JPA는 Native SQL을 통해 SQL을 직접 사용할 수 있는 기능을 제공.
- SQL을 개발자가 직접 정의
- 네이티브 SQL 사용 시 엔티티를 조회하고, JPA가 지원하는 영속성 컨텍스트의 기능을 그대로 사용 가능
 


